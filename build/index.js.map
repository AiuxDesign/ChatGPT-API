{"version":3,"sources":["../src/index.ts","../src/ConversationStore.ts","../src/types.ts","../src/Tokenizer.ts","../src/utils/request.ts","../src/utils/urls.ts","../src/utils/index.ts","../src/utils/log.ts","../src/Chatgpt.ts"],"sourcesContent":["export * from './Chatgpt'\r\nexport * from './types'","import Keyv from 'keyv'\r\nimport LRUCache from 'lru-cache'\r\nimport Tokenizer from './Tokenizer'\r\n\r\nimport {\r\n  IChatGPTHTTPDataMessage,\r\n  IConversationStoreParams,\r\n  TCommonMessage,\r\n  ERole,\r\n  TLog,\r\n} from './types'\r\n\r\n/**\r\n * conversation manage\r\n */\r\nexport default class ConversationStore {\r\n  #store: Keyv<TCommonMessage, any>\r\n  #lru: LRUCache<string, TCommonMessage>\r\n  /**\r\n   * in case some bad things happen\r\n   */\r\n  #maxFindDepth: number\r\n  #debug: boolean\r\n  #log: TLog\r\n  constructor(params: IConversationStoreParams) {\r\n    const { maxKeys = 100000, maxFindDepth = 20, debug, log } = params\r\n    this.#lru = new LRUCache<string, TCommonMessage>({\r\n      max: maxKeys,\r\n    })\r\n    this.#store = new Keyv<TCommonMessage, any>({\r\n      store: this.#lru,\r\n    })\r\n    this.#maxFindDepth = maxFindDepth\r\n    this.#debug = debug\r\n    this.#log = log\r\n\r\n    if (this.#debug) this.#log('ConversationStore params', params)\r\n  }\r\n  /**\r\n   * get message by id\r\n   * @param id\r\n   * @returns\r\n   */\r\n  async get(id: string): Promise<TCommonMessage | undefined> {\r\n    return await this.#store.get(id)\r\n  }\r\n  /**\r\n   * set new message\r\n   * @param msg\r\n   * @returns\r\n   */\r\n  async set(msgs: TCommonMessage[]) {\r\n    for (const msg of msgs) {\r\n      await this.#store.set(msg.id, msg)\r\n    }\r\n    if (this.#debug) this.#log('lru size', this.#lru.size)\r\n  }\r\n  /**\r\n   * check if the id exists in the store\r\n   * @param id\r\n   * @returns\r\n   */\r\n  async has(id: string): Promise<boolean> {\r\n    return await this.#store.has(id)\r\n  }\r\n  /**\r\n   * delete one message\r\n   * @param id\r\n   * @returns\r\n   */\r\n  async delete(id: string): Promise<boolean> {\r\n    return await this.#store.delete(id)\r\n  }\r\n  /**\r\n   * clear one conversation，it will be used when you set a new system prompt，which means that you will be in a new context，so early messages will be deleted\r\n   * @param id last conversation id\r\n   */\r\n  async clear1Conversation(id?: string) {\r\n    let parentMessageId: string | undefined = id\r\n    let cnt = 0\r\n    while (parentMessageId && cnt < this.#maxFindDepth) {\r\n      cnt++\r\n      const msg: TCommonMessage | undefined = await this.get(parentMessageId)\r\n      if (msg) {\r\n        await this.delete(msg.id)\r\n      }\r\n      parentMessageId = msg?.parentMessageId\r\n    }\r\n  }\r\n  /**\r\n   * find messages in a conversation by id\r\n   * @param id parentMessageId\r\n   */\r\n  async findMessages(opts: {\r\n    id: string | undefined\r\n    tokenizer: Tokenizer\r\n    limit: number\r\n    availableTokens: number\r\n    ignore: boolean\r\n  }) {\r\n    let {\r\n      id = undefined,\r\n      tokenizer,\r\n      limit,\r\n      availableTokens,\r\n      ignore = false,\r\n    } = opts\r\n    let parentMessageId: string | undefined = id\r\n    let cnt = 0\r\n    const messages: IChatGPTHTTPDataMessage[] = []\r\n    while (parentMessageId && cnt < this.#maxFindDepth) {\r\n      const msg: TCommonMessage | undefined = await this.#store.get(\r\n        parentMessageId,\r\n      )\r\n      if (msg && !(ignore && msg.role === ERole.assistant)) {\r\n        let tokensCnt = msg.tokens || tokenizer.getTokenCnt(msg.text)\r\n        if (tokensCnt <= limit) {\r\n          if (availableTokens < tokensCnt) break\r\n          messages.unshift({\r\n            role: msg.role,\r\n            content: msg.text,\r\n          })\r\n          cnt++\r\n          availableTokens -= tokensCnt\r\n        }\r\n      }\r\n      parentMessageId = msg?.parentMessageId\r\n    }\r\n    if (this.#debug) {\r\n      this.#log('availableTokens', availableTokens)\r\n    }\r\n    return messages\r\n  }\r\n  /**\r\n   * clear the store\r\n   */\r\n  async clearAll() {\r\n    await this.#store.clear()\r\n  }\r\n}\r\n","import { AxiosRequestConfig } from 'axios'\r\nimport { TiktokenEmbedding } from '@dqbd/tiktoken'\r\n/**\r\n * ChatCompletion 回答\r\n */\r\nexport interface IChatCompletion {\r\n  // {\r\n  //   \"id\": \"chatcmpl-6psB2OWQOgHwCWzTIsQMnhB3fst1J\",\r\n  //   \"object\": \"chat.completion\",\r\n  //   \"created\": 1677821004,\r\n  //   \"model\": \"gpt-3.5-turbo-0301\",\r\n  //   \"usage\": {\r\n  //     \"prompt_tokens\": 47,\r\n  //     \"completion_tokens\": 391,\r\n  //     \"total_tokens\": 438\r\n  //   },\r\n  //   \"choices\": [\r\n  //     {\r\n  //       \"message\": {\r\n  //         \"role\": \"assistant\",\r\n  //         \"content\": \"回答\"\r\n  //       },\r\n  //       \"finish_reason\": \"stop\",\r\n  //       \"index\": 0\r\n  //     }\r\n  //   ]\r\n  // }\r\n\r\n  id: string\r\n  object: string\r\n  created: number\r\n  model: string\r\n  usage: {\r\n    prompt_tokens: number\r\n    completion_tokens: number\r\n    total_tokens: number\r\n  }\r\n  choices: {\r\n    // content 即为答案\r\n    message: { role: string; content: string }\r\n    finish_reason: string\r\n    index: number\r\n  }[]\r\n}\r\n\r\nexport interface IChatCompletionErrReponseData {\r\n  message?: string\r\n  type?: string\r\n}\r\n\r\nexport interface IChatCompletionStreamOnEndData {\r\n  success: boolean\r\n  data: IChatGPTResponse | IChatCompletionErrReponseData\r\n  status: number\r\n}\r\n\r\nexport type TChatCompletionStreamOnEnd = (\r\n  endData: IChatCompletionStreamOnEndData,\r\n) => void\r\n\r\n/**\r\n * response message\r\n */\r\nexport interface IChatGPTResponse {\r\n  id: string\r\n  text: string\r\n  created: number\r\n  role: ERole\r\n  parentMessageId?: string\r\n  tokens?: number\r\n}\r\n/**\r\n * user message\r\n */\r\nexport interface IChatGPTUserMessage {\r\n  id: string\r\n  text: string\r\n  role: ERole\r\n  parentMessageId?: string\r\n  tokens?: number\r\n}\r\n/**\r\n * system situation message\r\n */\r\nexport interface IChatGPTSystemMessage {\r\n  id: string\r\n  text: string\r\n  role: ERole\r\n  parentMessageId?: string\r\n  tokens?: number\r\n}\r\nexport interface IChatGPTHTTPDataMessage {\r\n  role: ERole\r\n  content: string\r\n}\r\n\r\nexport enum ERole {\r\n  /**\r\n   * conversation situation\r\n   */\r\n  system = 'system',\r\n  /**\r\n   * role is user\r\n   */\r\n  user = 'user',\r\n  /**\r\n   * role is chatgpt\r\n   */\r\n  assistant = 'assistant',\r\n}\r\n\r\nexport interface IConversationStoreParams {\r\n  maxKeys?: number\r\n  maxFindDepth?: number\r\n  debug: boolean\r\n  log: TLog\r\n}\r\n\r\nexport interface IChatGPTParams {\r\n  /**\r\n   * apiKey, you can get it in https://platform.openai.com/account/api-keys,You can apply for up to 5 at most.\r\n   */\r\n  apiKey: string\r\n  /**\r\n   * model，default is 'gpt-3.5-turbo'\r\n   */\r\n  model?: string\r\n  /**\r\n   * print logs\r\n   */\r\n  debug?: boolean\r\n  /**\r\n   * axios configs\r\n   */\r\n  requestConfig?: AxiosRequestConfig\r\n  /**\r\n   * configs for store\r\n   */\r\n  storeConfig?: {\r\n    /**\r\n     * lru max keys, default `100000`\r\n     */\r\n    maxKeys?: number\r\n    /**\r\n     * Recursively search for historical messages, default `20` messages will be sent to the ChatGPT server\r\n     */\r\n    maxFindDepth?: number\r\n  }\r\n  tokenizerConfig?: ITokensParams\r\n  /**\r\n   * the maximum number of tokens when initiating a request, including prompts and completion. The default value is 4096.\r\n   */\r\n  maxTokens?: number\r\n  /**\r\n   * The maximum number of tokens for a single message. It is used to prevent from sending too many tokens to the ChatGPT server.\r\n   * If this number is exceeded, the message will be deleted and not passed on as a prompt to the chatGPT server. The default value is `1000`.\r\n   * - notice: **Maybe the message returned by ChatGPT should not be sent to the ChatGPT server as a prompt for the next conversation**.\r\n   */\r\n  limitTokensInAMessage?: number\r\n  /**\r\n   * same reason as `limitTokensInAMessage`, **Maybe the message returned by ChatGPT should not be sent to the ChatGPT server as a prompt for the next conversation**, default value is `false`\r\n   * - `true`: will ignore ChatGPT server message in the next sendMessage, and will only refer to `limitTokensInAMessage` in history messages\r\n   * - `false`: will only refer to `limitTokensInAMessage` in history messages\r\n   */\r\n  ignoreServerMessagesInPrompt?: boolean\r\n\r\n  log?: TLog \r\n}\r\n\r\n/**\r\n * Tokenizer params\r\n */\r\nexport interface ITokensParams {\r\n  /**\r\n   * \"gpt2\" | \"r50k_base\" | \"p50k_base\" | \"p50k_edit\" | \"cl100k_base\", default 'cl100k_base'\r\n   */\r\n  encoding?: TiktokenEmbedding\r\n\r\n  /**\r\n   * replace regexp\r\n   */\r\n  replaceReg?: RegExp\r\n  /**\r\n   * replace function\r\n   */\r\n  replaceCallback?: (...args: any[]) => string\r\n}\r\n\r\nexport type TCommonMessage =\r\n  | IChatGPTResponse\r\n  | IChatGPTUserMessage\r\n  | IChatGPTSystemMessage\r\n\r\n/**\r\n * Pass in your own logger\r\n */\r\nexport type TLog = (msg: string, ...args: any[]) => void","import { get_encoding, Tiktoken } from '@dqbd/tiktoken'\r\nimport { ITokensParams, TCommonMessage } from './types'\r\n\r\nexport default class Tokenizer {\r\n  #tokenizer: Tiktoken\r\n  #replaceReg: RegExp\r\n  #replaceCallback: (...args: any[]) => string\r\n  constructor(opts: ITokensParams) {\r\n    const {\r\n      encoding = 'cl100k_base',\r\n      replaceReg = /<\\|endoftext\\|>/g,\r\n      replaceCallback = (...args: any[]) => '',\r\n    } = opts\r\n    this.#tokenizer = get_encoding(encoding)\r\n    this.#replaceReg = replaceReg\r\n    this.#replaceCallback = replaceCallback\r\n  }\r\n  #encode(text: string): Uint32Array {\r\n    return this.#tokenizer.encode(text)\r\n  }\r\n  /**\r\n   * get the text tokens count\r\n   * @param text\r\n   * @returns\r\n   */\r\n  getTokenCnt(msg: TCommonMessage | string){\r\n    if(typeof msg === 'object' && msg.tokens) return msg.tokens\r\n    msg = typeof msg === 'object' ? msg.text : msg\r\n    const text = msg.replace(this.#replaceReg, this.#replaceCallback)\r\n    return this.#encode(text).length\r\n  }\r\n}\r\n\r\n// const token = new Tokenizer({\r\n//   replaceReg: /hello|world/g,\r\n//   replaceCallback(c: string) {\r\n//     return 'ok'\r\n//   },\r\n// })\r\n// console.log(token.getTokenCnt('hello world'))\r\n","import axios from 'axios'\r\nimport { RawAxiosRequestConfig } from 'axios'\r\nimport { TLog } from '../types'\r\n\r\ninterface IRequestOpts {\r\n  debug: boolean\r\n  log: TLog\r\n}\r\n\r\n// export async function get(config: RawAxiosRequestConfig, opts: IRequestOpts) {\r\n//   const ins = axios.create({\r\n//     method: 'GET',\r\n//   })\r\n//   if (opts.debug) {\r\n//     ins.interceptors.request.use((config) => {\r\n//       log('axios config', config)\r\n//       return config\r\n//     })\r\n//   }\r\n//   return (await ins({ ...config })).data\r\n// }\r\nexport async function post(config: RawAxiosRequestConfig, opts: IRequestOpts) {\r\n  const { debug, log } = opts\r\n  const ins = axios.create({\r\n    method: 'POST',\r\n    validateStatus(status) {\r\n      return true\r\n    },\r\n  })\r\n  if (debug) {\r\n    ins.interceptors.request.use((config) => {\r\n      log('axios config', {\r\n        headers: config.headers,\r\n        data: config.data,\r\n      })\r\n      return config\r\n    })\r\n  }\r\n  const response = await ins({ ...config })\r\n  return response\r\n}\r\n\r\n// if (response.status >= 200 && response.status < 300) {\r\n//   console.log('[response]', response.data)\r\n// } else {\r\n//   console.log('[response]', {\r\n//     data: {\r\n//       message: response.data.error.message,\r\n//       type: response.data.error.type,\r\n//       code: response.data.error.code,\r\n//     },\r\n//     status: response.status,\r\n//   })\r\n// }\r\n","/**\n * docs https://platform.openai.com/docs/api-reference/chat\n */\nconst urls = {\n  listModels: 'https://api.openai.com/v1/models', // get\n  createCompletion: 'https://api.openai.com/v1/completions', // post\n  createChatCompletion: 'https://api.openai.com/v1/chat/completions' // post\n}\n\nexport default urls\n","import { v4 as uuid } from 'uuid'\r\nimport { stdin, stdout } from 'process'\r\nimport { createInterface } from 'readline'\r\nexport * from './log'\r\n\r\nexport function getReadLine() {\r\n  const rl = createInterface({ input: stdin, output: stdout })\r\n  const iter = rl[Symbol.asyncIterator]()\r\n  return async () => (await iter.next()).value\r\n}\r\n\r\n/**\r\n * generate unique id by uuidV4\r\n */\r\nexport function genId() {\r\n  return uuid()\r\n}\r\n","export function log(...args: any[]) {\r\n  console.log('----------------------------------')\r\n  console.log(...args)\r\n}\r\n","import { AxiosRequestConfig } from 'axios'\r\n\r\nimport ConversationStore from './ConversationStore'\r\nimport Tokenizer from './Tokenizer'\r\nimport {\r\n  IChatCompletion,\r\n  IChatGPTResponse,\r\n  IChatGPTUserMessage,\r\n  IChatGPTSystemMessage,\r\n  ERole,\r\n  IChatGPTHTTPDataMessage,\r\n  IChatGPTParams,\r\n  IChatCompletionStreamOnEndData,\r\n  IChatCompletionErrReponseData,\r\n  TLog,\r\n} from './types'\r\nimport { post } from './utils/request'\r\nimport URLS from './utils/urls'\r\nimport { genId, log as defaultLog } from './utils'\r\n\r\n// https://platform.openai.com/docs/api-reference/chat\r\n// curl https://api.openai.com/v1/chat/completions \\\r\n//   -H 'Content-Type: application/json' \\\r\n//   -H 'Authorization: Bearer YOUR_API_KEY' \\\r\n//   -d '{\r\n//   \"model\": \"gpt-3.5-turbo\",\r\n//   \"messages\": [{\"role\": \"user\", \"content\": \"Hello!\"}]\r\n// }'\r\n\r\nfunction genDefaultSystemMessage(): IChatGPTHTTPDataMessage {\r\n  const currentDate = new Date().toISOString().split('T')[0]\r\n  return {\r\n    role: ERole.system,\r\n    content: `You are ChatGPT, a large language model trained by OpenAI. Answer as concisely as possible.\\nKnowledge cutoff: 2021-09-01\\nCurrent date: ${currentDate}`,\r\n  }\r\n}\r\n\r\n// role https://platform.openai.com/docs/guides/chat/introduction\r\nexport class ChatGPT {\r\n  #apiKey = ''\r\n  #model = ''\r\n  #urls = URLS\r\n  #debug = false\r\n  #requestConfig: AxiosRequestConfig\r\n  #store: ConversationStore\r\n  #tokenizer: Tokenizer\r\n  #maxTokens: number\r\n  #limitTokensInAMessage: number\r\n  #ignoreServerMessagesInPrompt: boolean\r\n  #log: TLog\r\n  constructor(opts: IChatGPTParams) {\r\n    const {\r\n      apiKey,\r\n      model = 'gpt-3.5-turbo',\r\n      debug = false,\r\n      requestConfig = {},\r\n      storeConfig = {},\r\n      tokenizerConfig = {},\r\n      maxTokens = 4096,\r\n      limitTokensInAMessage = 1000,\r\n      ignoreServerMessagesInPrompt = false,\r\n      log = defaultLog,\r\n    } = opts\r\n\r\n    this.#apiKey = apiKey\r\n    this.#model = model\r\n    this.#debug = debug\r\n    this.#requestConfig = requestConfig\r\n    this.#tokenizer = new Tokenizer(tokenizerConfig)\r\n    this.#maxTokens = maxTokens\r\n    this.#limitTokensInAMessage = limitTokensInAMessage\r\n    this.#ignoreServerMessagesInPrompt = ignoreServerMessagesInPrompt\r\n    this.#log = log\r\n\r\n    this.#store = new ConversationStore({\r\n      ...storeConfig,\r\n      debug: this.#debug,\r\n      log: this.#log,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * send message to ChatGPT server\r\n   * @param opts.text new message\r\n   * @param opts.systemPrompt prompt message\r\n   * @param opts.parentMessageId\r\n   */\r\n  sendMessage(\r\n    opts:\r\n      | {\r\n          text: string\r\n          systemPrompt?: string\r\n          parentMessageId?: string\r\n          onProgress?: (t: string) => void\r\n          onEnd?: (d: IChatCompletionStreamOnEndData) => void\r\n        }\r\n      | string,\r\n  ) {\r\n    return new Promise<IChatCompletionStreamOnEndData | null>(\r\n      async (resolve, reject) => {\r\n        opts = typeof opts === 'string' ? { text: opts } : opts\r\n        let {\r\n          text,\r\n          systemPrompt = undefined,\r\n          parentMessageId = undefined,\r\n          onProgress = false,\r\n          onEnd = () => {},\r\n        } = opts\r\n        if (systemPrompt) {\r\n          if (parentMessageId)\r\n            await this.#store.clear1Conversation(parentMessageId)\r\n          parentMessageId = undefined\r\n        }\r\n        const userMessage: IChatGPTUserMessage = {\r\n          id: genId(),\r\n          text,\r\n          role: ERole.user,\r\n          parentMessageId,\r\n          tokens: this.#tokenizer.getTokenCnt(text),\r\n        }\r\n        const messages = await this.#makeConversations(\r\n          userMessage,\r\n          systemPrompt,\r\n        )\r\n        if (this.#debug) {\r\n          this.#log('messages', messages)\r\n        }\r\n        if (onProgress) {\r\n          const responseMessage: IChatGPTResponse = {\r\n            id: genId(),\r\n            text: '',\r\n            created: Math.floor(Date.now() / 1000),\r\n            role: ERole.assistant,\r\n            parentMessageId: userMessage.id,\r\n            tokens: 0,\r\n          }\r\n          const innerOnEnd = async () => {\r\n            const msgsToBeStored = [userMessage, responseMessage]\r\n            if (systemPrompt) {\r\n              const systemMessage: IChatGPTSystemMessage = {\r\n                id: genId(),\r\n                text: systemPrompt,\r\n                role: ERole.system,\r\n                tokens: this.#tokenizer.getTokenCnt(systemPrompt),\r\n              }\r\n              userMessage.parentMessageId = systemMessage.id\r\n              msgsToBeStored.unshift(systemMessage)\r\n            }\r\n            await this.#store.set(msgsToBeStored)\r\n            resolve(null)\r\n          }\r\n          await this.#streamChat(\r\n            messages,\r\n            onProgress,\r\n            responseMessage,\r\n            innerOnEnd,\r\n            onEnd,\r\n          )\r\n        } else {\r\n          const chatResponse = await this.#chat(messages)\r\n          if (!chatResponse.success) {\r\n            return resolve({\r\n              ...chatResponse,\r\n              data: chatResponse.data as IChatCompletionErrReponseData,\r\n            })\r\n          }\r\n          const res = chatResponse.data as IChatCompletion\r\n          const responseMessage: IChatGPTResponse = {\r\n            id: genId(),\r\n            text: res?.choices[0]?.message?.content,\r\n            created: res.created,\r\n            role: ERole.assistant,\r\n            parentMessageId: userMessage.id,\r\n            tokens: res?.usage?.completion_tokens,\r\n          }\r\n          const msgsToBeStored = [userMessage, responseMessage]\r\n          if (systemPrompt) {\r\n            const systemMessage: IChatGPTSystemMessage = {\r\n              id: genId(),\r\n              text: systemPrompt,\r\n              role: ERole.system,\r\n              tokens: this.#tokenizer.getTokenCnt(systemPrompt),\r\n            }\r\n            userMessage.parentMessageId = systemMessage.id\r\n            msgsToBeStored.unshift(systemMessage)\r\n          }\r\n          await this.#store.set(msgsToBeStored)\r\n          resolve({\r\n            success: true,\r\n            data: responseMessage,\r\n            status: chatResponse.status,\r\n          })\r\n        }\r\n      },\r\n    )\r\n  }\r\n\r\n  async #streamChat(\r\n    messages: { content: string; role: ERole }[],\r\n    onProgress: boolean | ((t: string) => void),\r\n    responseMessagge: IChatGPTResponse,\r\n    innerOnEnd: () => void,\r\n    onEnd?: (d: IChatCompletionStreamOnEndData) => void,\r\n  ) {\r\n    const axiosResponse = await post(\r\n      {\r\n        url: this.#urls.createChatCompletion,\r\n        ...this.#requestConfig,\r\n        headers: {\r\n          Authorization: this.#genAuthorization(),\r\n          'Content-Type': 'application/json',\r\n          ...{ ...(this.#requestConfig.headers || {}) },\r\n        },\r\n        data: {\r\n          stream: true,\r\n          model: this.#model,\r\n          messages,\r\n          ...{ ...(this.#requestConfig.data || {}) },\r\n        },\r\n        responseType: 'stream',\r\n      },\r\n      {\r\n        debug: this.#debug,\r\n        log: this.#log,\r\n      },\r\n    )\r\n    const stream = axiosResponse.data\r\n    const status = axiosResponse.status\r\n    if (this.#validateAxiosResponse(status)) {\r\n      stream.on('data', (buf: any) => {\r\n        const dataArr = buf.toString().split('\\n')\r\n        let onDataPieceText = ''\r\n        for (const dataStr of dataArr) {\r\n          // split 之后的空行，或者结束通知\r\n          if (dataStr.indexOf('data: ') !== 0 || dataStr === 'data: [DONE]')\r\n            continue\r\n          const parsedData = JSON.parse(dataStr.slice(6)) // [data: ]\r\n          const pieceText = parsedData.choices[0].delta.content || ''\r\n          onDataPieceText += pieceText\r\n        }\r\n        if (typeof onProgress === 'function') {\r\n          onProgress(onDataPieceText)\r\n        }\r\n        responseMessagge.text += onDataPieceText\r\n      })\r\n      stream.on('end', async () => {\r\n        responseMessagge.tokens = this.#tokenizer.getTokenCnt(\r\n          responseMessagge.text,\r\n        )\r\n        await innerOnEnd()\r\n        onEnd &&\r\n          onEnd({\r\n            success: true,\r\n            data: responseMessagge,\r\n            status: axiosResponse.status,\r\n          })\r\n      })\r\n    } else {\r\n      let data: any = stream.on('data', (buf: any) => {\r\n        data = JSON.parse(buf.toString())\r\n        // that is stream\r\n        // error: {\r\n        //     message: 'Your access was terminated due to violation of our policies, please check your email for more information. If you believe this is in error and would like to appeal, please contact support@openai.com.',\r\n        //     type: 'access_terminated',\r\n        //     param: null,\r\n        //     code: null\r\n        //   }\r\n        // }\r\n      })\r\n      stream.on('end', () => {\r\n        onEnd &&\r\n          onEnd({\r\n            success: false,\r\n            data: {\r\n              message: data?.error?.message,\r\n              type: data?.error?.type,\r\n            },\r\n            status,\r\n          })\r\n      })\r\n    }\r\n  }\r\n\r\n  async #chat(messages: { content: string; role: ERole }[]) {\r\n    const axiosResponse = await post(\r\n      {\r\n        url: this.#urls.createChatCompletion,\r\n        ...this.#requestConfig,\r\n        headers: {\r\n          Authorization: this.#genAuthorization(),\r\n          'Content-Type': 'application/json',\r\n          ...{ ...(this.#requestConfig.headers || {}) },\r\n        },\r\n        data: {\r\n          model: this.#model,\r\n          messages,\r\n          ...{ ...(this.#requestConfig.data || {}) },\r\n        },\r\n      },\r\n      {\r\n        debug: this.#debug,\r\n        log: this.#log,\r\n      },\r\n    )\r\n    // this.#logger('[#chat]', axiosResponse.status)\r\n    const data = axiosResponse.data\r\n    const status = axiosResponse.status\r\n    if (this.#validateAxiosResponse(status)) {\r\n      return {\r\n        success: true,\r\n        data: data as IChatCompletion,\r\n        status,\r\n      }\r\n    } else {\r\n      return {\r\n        success: false,\r\n        data: {\r\n          message: data?.error?.message,\r\n          type: data?.error?.type,\r\n        },\r\n        status,\r\n      }\r\n    }\r\n  }\r\n\r\n  #validateAxiosResponse(status: number) {\r\n    return status >= 200 && status < 300\r\n  }\r\n\r\n  /**\r\n   * make conversations for http request data.messages\r\n   */\r\n  async #makeConversations(userMessage: IChatGPTUserMessage, prompt?: string) {\r\n    let messages: IChatGPTHTTPDataMessage[] = []\r\n    let usedTokens = this.#tokenizer.getTokenCnt(userMessage.text)\r\n    if (prompt) {\r\n      messages.push({\r\n        role: ERole.system,\r\n        content: prompt,\r\n      })\r\n    } else {\r\n      messages = await this.#store.findMessages({\r\n        id: userMessage.parentMessageId,\r\n        tokenizer: this.#tokenizer,\r\n        limit: this.#limitTokensInAMessage,\r\n        availableTokens: this.#maxTokens - usedTokens,\r\n        ignore: this.#ignoreServerMessagesInPrompt,\r\n      })\r\n    }\r\n    /**\r\n     * if there are no default system massage, add one\r\n     */\r\n    if (!messages.length || messages[0].role !== ERole.system) {\r\n      messages.unshift(genDefaultSystemMessage())\r\n    }\r\n    messages.push({\r\n      role: ERole.user,\r\n      content: userMessage.text,\r\n    })\r\n    return messages\r\n  }\r\n\r\n  async clear1Conversation(parentMessageId?: string) {\r\n    return await this.#store.clear1Conversation(parentMessageId)\r\n  }\r\n\r\n  /**\r\n   * generate HTTP Authorization\r\n   * @returns\r\n   */\r\n  #genAuthorization() {\r\n    return `Bearer ${this.#apiKey}`\r\n  }\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,kBAAiB;AACjB,uBAAqB;;;AC+Fd,IAAK,QAAL,kBAAKA,WAAL;AAIL,EAAAA,OAAA,YAAS;AAIT,EAAAA,OAAA,UAAO;AAIP,EAAAA,OAAA,eAAY;AAZF,SAAAA;AAAA,GAAA;;;ADhGZ;AAeA,IAAqB,oBAArB,MAAuC;AAAA,EASrC,YAAY,QAAkC;AAR9C;AACA;AAIA;AAAA;AAAA;AAAA;AACA;AACA;AAEE,UAAM,EAAE,UAAU,KAAQ,eAAe,IAAI,OAAO,KAAAC,KAAI,IAAI;AAC5D,uBAAK,MAAO,IAAI,iBAAAC,QAAiC;AAAA,MAC/C,KAAK;AAAA,IACP,CAAC;AACD,uBAAK,QAAS,IAAI,YAAAC,QAA0B;AAAA,MAC1C,OAAO,mBAAK;AAAA,IACd,CAAC;AACD,uBAAK,eAAgB;AACrB,uBAAK,QAAS;AACd,uBAAK,MAAOF;AAEZ,QAAI,mBAAK;AAAQ,yBAAK,MAAL,WAAU,4BAA4B;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,IAAI,IAAiD;AACzD,WAAO,MAAM,mBAAK,QAAO,IAAI,EAAE;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,IAAI,MAAwB;AAChC,eAAW,OAAO,MAAM;AACtB,YAAM,mBAAK,QAAO,IAAI,IAAI,IAAI,GAAG;AAAA,IACnC;AACA,QAAI,mBAAK;AAAQ,yBAAK,MAAL,WAAU,YAAY,mBAAK,MAAK;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,IAAI,IAA8B;AACtC,WAAO,MAAM,mBAAK,QAAO,IAAI,EAAE;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,OAAO,IAA8B;AACzC,WAAO,MAAM,mBAAK,QAAO,OAAO,EAAE;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAmB,IAAa;AACpC,QAAI,kBAAsC;AAC1C,QAAI,MAAM;AACV,WAAO,mBAAmB,MAAM,mBAAK,gBAAe;AAClD;AACA,YAAM,MAAkC,MAAM,KAAK,IAAI,eAAe;AACtE,UAAI,KAAK;AACP,cAAM,KAAK,OAAO,IAAI,EAAE;AAAA,MAC1B;AACA,wBAAkB,2BAAK;AAAA,IACzB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,MAMhB;AACD,QAAI;AAAA,MACF,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS;AAAA,IACX,IAAI;AACJ,QAAI,kBAAsC;AAC1C,QAAI,MAAM;AACV,UAAM,WAAsC,CAAC;AAC7C,WAAO,mBAAmB,MAAM,mBAAK,gBAAe;AAClD,YAAM,MAAkC,MAAM,mBAAK,QAAO;AAAA,QACxD;AAAA,MACF;AACA,UAAI,OAAO,EAAE,UAAU,IAAI,uCAA2B;AACpD,YAAI,YAAY,IAAI,UAAU,UAAU,YAAY,IAAI,IAAI;AAC5D,YAAI,aAAa,OAAO;AACtB,cAAI,kBAAkB;AAAW;AACjC,mBAAS,QAAQ;AAAA,YACf,MAAM,IAAI;AAAA,YACV,SAAS,IAAI;AAAA,UACf,CAAC;AACD;AACA,6BAAmB;AAAA,QACrB;AAAA,MACF;AACA,wBAAkB,2BAAK;AAAA,IACzB;AACA,QAAI,mBAAK,SAAQ;AACf,yBAAK,MAAL,WAAU,mBAAmB;AAAA,IAC/B;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,WAAW;AACf,UAAM,mBAAK,QAAO,MAAM;AAAA,EAC1B;AACF;AA3HE;AACA;AAIA;AACA;AACA;;;AEvBF,sBAAuC;AAAvC;AAGA,IAAqB,YAArB,MAA+B;AAAA,EAI7B,YAAY,MAAqB;AAUjC;AAbA;AACA;AACA;AAEE,UAAM;AAAA,MACJ,WAAW;AAAA,MACX,aAAa;AAAA,MACb,kBAAkB,IAAI,SAAgB;AAAA,IACxC,IAAI;AACJ,uBAAK,gBAAa,8BAAa,QAAQ;AACvC,uBAAK,aAAc;AACnB,uBAAK,kBAAmB;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,YAAY,KAA6B;AACvC,QAAG,OAAO,QAAQ,YAAY,IAAI;AAAQ,aAAO,IAAI;AACrD,UAAM,OAAO,QAAQ,WAAW,IAAI,OAAO;AAC3C,UAAM,OAAO,IAAI,QAAQ,mBAAK,cAAa,mBAAK,iBAAgB;AAChE,WAAO,sBAAK,oBAAL,WAAa,MAAM;AAAA,EAC5B;AACF;AA3BE;AACA;AACA;AAWA;AAAA,YAAO,SAAC,MAA2B;AACjC,SAAO,mBAAK,YAAW,OAAO,IAAI;AACpC;;;ACnBF,mBAAkB;AAqBlB,eAAsB,KAAK,QAA+B,MAAoB;AAC5E,QAAM,EAAE,OAAO,KAAAG,KAAI,IAAI;AACvB,QAAM,MAAM,aAAAC,QAAM,OAAO;AAAA,IACvB,QAAQ;AAAA,IACR,eAAe,QAAQ;AACrB,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AACD,MAAI,OAAO;AACT,QAAI,aAAa,QAAQ,IAAI,CAACC,YAAW;AACvC,MAAAF,KAAI,gBAAgB;AAAA,QAClB,SAASE,QAAO;AAAA,QAChB,MAAMA,QAAO;AAAA,MACf,CAAC;AACD,aAAOA;AAAA,IACT,CAAC;AAAA,EACH;AACA,QAAM,WAAW,MAAM,IAAI,EAAE,GAAG,OAAO,CAAC;AACxC,SAAO;AACT;;;ACrCA,IAAM,OAAO;AAAA,EACX,YAAY;AAAA;AAAA,EACZ,kBAAkB;AAAA;AAAA,EAClB,sBAAsB;AAAA;AACxB;AAEA,IAAO,eAAQ;;;ACTf,kBAA2B;;;ACApB,SAAS,OAAO,MAAa;AAClC,UAAQ,IAAI,oCAAoC;AAChD,UAAQ,IAAI,GAAG,IAAI;AACrB;;;ADWO,SAAS,QAAQ;AACtB,aAAO,YAAAC,IAAK;AACd;;;AEaA,SAAS,0BAAmD;AAC1D,QAAM,eAAc,oBAAI,KAAK,GAAE,YAAY,EAAE,MAAM,GAAG,EAAE,CAAC;AACzD,SAAO;AAAA,IACL;AAAA,IACA,SAAS;AAAA;AAAA,gBAA4I;AAAA,EACvJ;AACF;AAnCA,4BAAAC,SAAA,gBAAAC,SAAAC,aAAA,mEAAAC,OAAA;AAsCO,IAAM,UAAN,MAAc;AAAA,EAYnB,YAAY,MAAsB;AAmJlC,uBAAM;AAsFN,uBAAM;AA0CN;AAOA;AAAA;AAAA;AAAA,uBAAM;AAsCN;AAAA;AAAA;AAAA;AAAA;AA3UA,gCAAU;AACV,+BAAS;AACT,8BAAQ;AACR,uBAAAH,SAAS;AACT;AACA,uBAAAC,SAAA;AACA,uBAAAC,aAAA;AACA;AACA;AACA;AACA,uBAAAC,OAAA;AAEE,UAAM;AAAA,MACJ;AAAA,MACA,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,gBAAgB,CAAC;AAAA,MACjB,cAAc,CAAC;AAAA,MACf,kBAAkB,CAAC;AAAA,MACnB,YAAY;AAAA,MACZ,wBAAwB;AAAA,MACxB,+BAA+B;AAAA,MAC/B,KAAAC,OAAM;AAAA,IACR,IAAI;AAEJ,uBAAK,SAAU;AACf,uBAAK,QAAS;AACd,uBAAKJ,SAAS;AACd,uBAAK,gBAAiB;AACtB,uBAAKE,aAAa,IAAI,UAAU,eAAe;AAC/C,uBAAK,YAAa;AAClB,uBAAK,wBAAyB;AAC9B,uBAAK,+BAAgC;AACrC,uBAAKC,OAAOC;AAEZ,uBAAKH,SAAS,IAAI,kBAAkB;AAAA,MAClC,GAAG;AAAA,MACH,OAAO,mBAAKD;AAAA,MACZ,KAAK,mBAAKG;AAAA,IACZ,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YACE,MASA;AACA,WAAO,IAAI;AAAA,MACT,OAAO,SAAS,WAAW;AAnGjC;AAoGQ,eAAO,OAAO,SAAS,WAAW,EAAE,MAAM,KAAK,IAAI;AACnD,YAAI;AAAA,UACF;AAAA,UACA,eAAe;AAAA,UACf,kBAAkB;AAAA,UAClB,aAAa;AAAA,UACb,QAAQ,MAAM;AAAA,UAAC;AAAA,QACjB,IAAI;AACJ,YAAI,cAAc;AAChB,cAAI;AACF,kBAAM,mBAAKF,SAAO,mBAAmB,eAAe;AACtD,4BAAkB;AAAA,QACpB;AACA,cAAM,cAAmC;AAAA,UACvC,IAAI,MAAM;AAAA,UACV;AAAA,UACA;AAAA,UACA;AAAA,UACA,QAAQ,mBAAKC,aAAW,YAAY,IAAI;AAAA,QAC1C;AACA,cAAM,WAAW,MAAM,sBAAK,0CAAL,WACrB,aACA;AAEF,YAAI,mBAAKF,UAAQ;AACf,6BAAKG,OAAL,WAAU,YAAY;AAAA,QACxB;AACA,YAAI,YAAY;AACd,gBAAM,kBAAoC;AAAA,YACxC,IAAI,MAAM;AAAA,YACV,MAAM;AAAA,YACN,SAAS,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AAAA,YACrC;AAAA,YACA,iBAAiB,YAAY;AAAA,YAC7B,QAAQ;AAAA,UACV;AACA,gBAAM,aAAa,YAAY;AAC7B,kBAAM,iBAAiB,CAAC,aAAa,eAAe;AACpD,gBAAI,cAAc;AAChB,oBAAM,gBAAuC;AAAA,gBAC3C,IAAI,MAAM;AAAA,gBACV,MAAM;AAAA,gBACN;AAAA,gBACA,QAAQ,mBAAKD,aAAW,YAAY,YAAY;AAAA,cAClD;AACA,0BAAY,kBAAkB,cAAc;AAC5C,6BAAe,QAAQ,aAAa;AAAA,YACtC;AACA,kBAAM,mBAAKD,SAAO,IAAI,cAAc;AACpC,oBAAQ,IAAI;AAAA,UACd;AACA,gBAAM,sBAAK,4BAAL,WACJ,UACA,YACA,iBACA,YACA;AAAA,QAEJ,OAAO;AACL,gBAAM,eAAe,MAAM,sBAAK,gBAAL,WAAW;AACtC,cAAI,CAAC,aAAa,SAAS;AACzB,mBAAO,QAAQ;AAAA,cACb,GAAG;AAAA,cACH,MAAM,aAAa;AAAA,YACrB,CAAC;AAAA,UACH;AACA,gBAAM,MAAM,aAAa;AACzB,gBAAM,kBAAoC;AAAA,YACxC,IAAI,MAAM;AAAA,YACV,OAAM,sCAAK,QAAQ,OAAb,mBAAiB,YAAjB,mBAA0B;AAAA,YAChC,SAAS,IAAI;AAAA,YACb;AAAA,YACA,iBAAiB,YAAY;AAAA,YAC7B,SAAQ,gCAAK,UAAL,mBAAY;AAAA,UACtB;AACA,gBAAM,iBAAiB,CAAC,aAAa,eAAe;AACpD,cAAI,cAAc;AAChB,kBAAM,gBAAuC;AAAA,cAC3C,IAAI,MAAM;AAAA,cACV,MAAM;AAAA,cACN;AAAA,cACA,QAAQ,mBAAKC,aAAW,YAAY,YAAY;AAAA,YAClD;AACA,wBAAY,kBAAkB,cAAc;AAC5C,2BAAe,QAAQ,aAAa;AAAA,UACtC;AACA,gBAAM,mBAAKD,SAAO,IAAI,cAAc;AACpC,kBAAQ;AAAA,YACN,SAAS;AAAA,YACT,MAAM;AAAA,YACN,QAAQ,aAAa;AAAA,UACvB,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAuKA,MAAM,mBAAmB,iBAA0B;AACjD,WAAO,MAAM,mBAAKA,SAAO,mBAAmB,eAAe;AAAA,EAC7D;AASF;AA9UE;AACA;AACA;AACAD,UAAA;AACA;AACAC,UAAA;AACAC,cAAA;AACA;AACA;AACA;AACAC,QAAA;AAoJM;AAAA,gBAAW,eACf,UACA,YACA,kBACA,YACA,OACA;AACA,QAAM,gBAAgB,MAAM;AAAA,IAC1B;AAAA,MACE,KAAK,mBAAK,OAAM;AAAA,MAChB,GAAG,mBAAK;AAAA,MACR,SAAS;AAAA,QACP,eAAe,sBAAK,wCAAL;AAAA,QACf,gBAAgB;AAAA,QAChB,GAAG,EAAE,GAAI,mBAAK,gBAAe,WAAW,CAAC,EAAG;AAAA,MAC9C;AAAA,MACA,MAAM;AAAA,QACJ,QAAQ;AAAA,QACR,OAAO,mBAAK;AAAA,QACZ;AAAA,QACA,GAAG,EAAE,GAAI,mBAAK,gBAAe,QAAQ,CAAC,EAAG;AAAA,MAC3C;AAAA,MACA,cAAc;AAAA,IAChB;AAAA,IACA;AAAA,MACE,OAAO,mBAAKH;AAAA,MACZ,KAAK,mBAAKG;AAAA,IACZ;AAAA,EACF;AACA,QAAM,SAAS,cAAc;AAC7B,QAAM,SAAS,cAAc;AAC7B,MAAI,sBAAK,kDAAL,WAA4B,SAAS;AACvC,WAAO,GAAG,QAAQ,CAAC,QAAa;AAC9B,YAAM,UAAU,IAAI,SAAS,EAAE,MAAM,IAAI;AACzC,UAAI,kBAAkB;AACtB,iBAAW,WAAW,SAAS;AAE7B,YAAI,QAAQ,QAAQ,QAAQ,MAAM,KAAK,YAAY;AACjD;AACF,cAAM,aAAa,KAAK,MAAM,QAAQ,MAAM,CAAC,CAAC;AAC9C,cAAM,YAAY,WAAW,QAAQ,CAAC,EAAE,MAAM,WAAW;AACzD,2BAAmB;AAAA,MACrB;AACA,UAAI,OAAO,eAAe,YAAY;AACpC,mBAAW,eAAe;AAAA,MAC5B;AACA,uBAAiB,QAAQ;AAAA,IAC3B,CAAC;AACD,WAAO,GAAG,OAAO,YAAY;AAC3B,uBAAiB,SAAS,mBAAKD,aAAW;AAAA,QACxC,iBAAiB;AAAA,MACnB;AACA,YAAM,WAAW;AACjB,eACE,MAAM;AAAA,QACJ,SAAS;AAAA,QACT,MAAM;AAAA,QACN,QAAQ,cAAc;AAAA,MACxB,CAAC;AAAA,IACL,CAAC;AAAA,EACH,OAAO;AACL,QAAI,OAAY,OAAO,GAAG,QAAQ,CAAC,QAAa;AAC9C,aAAO,KAAK,MAAM,IAAI,SAAS,CAAC;AAAA,IASlC,CAAC;AACD,WAAO,GAAG,OAAO,MAAM;AA7Q7B;AA8QQ,eACE,MAAM;AAAA,QACJ,SAAS;AAAA,QACT,MAAM;AAAA,UACJ,UAAS,kCAAM,UAAN,mBAAa;AAAA,UACtB,OAAM,kCAAM,UAAN,mBAAa;AAAA,QACrB;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACL,CAAC;AAAA,EACH;AACF;AAEM;AAAA,UAAK,eAAC,UAA8C;AA3R5D;AA4RI,QAAM,gBAAgB,MAAM;AAAA,IAC1B;AAAA,MACE,KAAK,mBAAK,OAAM;AAAA,MAChB,GAAG,mBAAK;AAAA,MACR,SAAS;AAAA,QACP,eAAe,sBAAK,wCAAL;AAAA,QACf,gBAAgB;AAAA,QAChB,GAAG,EAAE,GAAI,mBAAK,gBAAe,WAAW,CAAC,EAAG;AAAA,MAC9C;AAAA,MACA,MAAM;AAAA,QACJ,OAAO,mBAAK;AAAA,QACZ;AAAA,QACA,GAAG,EAAE,GAAI,mBAAK,gBAAe,QAAQ,CAAC,EAAG;AAAA,MAC3C;AAAA,IACF;AAAA,IACA;AAAA,MACE,OAAO,mBAAKF;AAAA,MACZ,KAAK,mBAAKG;AAAA,IACZ;AAAA,EACF;AAEA,QAAM,OAAO,cAAc;AAC3B,QAAM,SAAS,cAAc;AAC7B,MAAI,sBAAK,kDAAL,WAA4B,SAAS;AACvC,WAAO;AAAA,MACL,SAAS;AAAA,MACT;AAAA,MACA;AAAA,IACF;AAAA,EACF,OAAO;AACL,WAAO;AAAA,MACL,SAAS;AAAA,MACT,MAAM;AAAA,QACJ,UAAS,kCAAM,UAAN,mBAAa;AAAA,QACtB,OAAM,kCAAM,UAAN,mBAAa;AAAA,MACrB;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAEA;AAAA,2BAAsB,SAAC,QAAgB;AACrC,SAAO,UAAU,OAAO,SAAS;AACnC;AAKM;AAAA,uBAAkB,eAAC,aAAkC,QAAiB;AAC1E,MAAI,WAAsC,CAAC;AAC3C,MAAI,aAAa,mBAAKD,aAAW,YAAY,YAAY,IAAI;AAC7D,MAAI,QAAQ;AACV,aAAS,KAAK;AAAA,MACZ;AAAA,MACA,SAAS;AAAA,IACX,CAAC;AAAA,EACH,OAAO;AACL,eAAW,MAAM,mBAAKD,SAAO,aAAa;AAAA,MACxC,IAAI,YAAY;AAAA,MAChB,WAAW,mBAAKC;AAAA,MAChB,OAAO,mBAAK;AAAA,MACZ,iBAAiB,mBAAK,cAAa;AAAA,MACnC,QAAQ,mBAAK;AAAA,IACf,CAAC;AAAA,EACH;AAIA,MAAI,CAAC,SAAS,UAAU,SAAS,CAAC,EAAE,gCAAuB;AACzD,aAAS,QAAQ,wBAAwB,CAAC;AAAA,EAC5C;AACA,WAAS,KAAK;AAAA,IACZ;AAAA,IACA,SAAS,YAAY;AAAA,EACvB,CAAC;AACD,SAAO;AACT;AAUA;AAAA,sBAAiB,WAAG;AAClB,SAAO,UAAU,mBAAK;AACxB;","names":["ERole","log","LRUCache","Keyv","log","axios","config","uuid","_debug","_store","_tokenizer","_log","log"]}